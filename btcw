import tensorflow as tf
tf.config.run_functions_eagerly(True)
import ccxt
import ta
import time
import pytz
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from binance.client import Client
from binance.enums import *
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional
from datetime import datetime
from tqdm import tqdm
from tensorflow.keras.layers import Flatten
from ta.momentum import RSIIndicator
from datetime import datetime, timedelta
from tensorflow.keras.layers import Dropout
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.layers import SimpleRNN
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.optimizers import Adam


# Definição dos parâmetros
PAIR = 'BTC/USDT'
PREDICT_DAYS = 10
BATCH_SIZE = 32
EPOCHS = 10
INTERVAL = '1h'  # intervalo de 1 HORA
LSTM_WINDOW = 20 # janela de 60 dias para a LSTM
LIMIT = 1000  # limite de 1000 barras (máximo permitido)
input_dim = 3
data_range = timedelta(days=365)

# Define o fuso horário para o horário de Brasília
brasil_tz = pytz.timezone('America/Sao_Paulo')


# Configurações
exchange_name = 'coinbasepro'  # Use 'binance', 'kraken', 'coinbasepro', etc.
pair = 'BTC/USDT'  # Par de moedas
interval = '1h'  # Intervalo das velas

# Criando a conexão com a exchange
exchange = getattr(ccxt, exchange_name)()

# Converte as datas para timestamp em milissegundos
# Define o período de busca dos dados
fim_dt = datetime.now()
inicio_dt = fim_dt - timedelta(days=90)

# Converte as datas para timestamp em milissegundos
inicio_ts = int(inicio_dt.timestamp() * 1000)
fim_ts = int(fim_dt.timestamp() * 1000)

# Cria uma lista vazia para armazenar todos os dados
all_data = []

# Calcula a diferença em horas
total_hours = int((fim_dt - inicio_dt).total_seconds() / 3600)


print ("BUSCANDO DADOS BTC-USD (PERIODO DE 1 ANO)...")

# Inicializa a barra de progresso
pbar = tqdm(total=total_hours)



while inicio_ts < fim_ts:

    # Busca os dados
    data = exchange.fetch_ohlcv(pair, interval, since=inicio_ts)

    # Se não retornar dados, sai do loop
    if not data:
        break

    # Adiciona os dados à nossa lista
    all_data += data

    # Atualiza o timestamp de início para o timestamp da última vela + intervalo
    inicio_ts = data[-1][0] + 1

    # Atualiza a barra de progresso
    pbar.update(len(data))

    # Pausa para evitar atingir o limite de requisições da API
    time.sleep(exchange.rateLimit / 1000)

pbar.close()


print("Número total de velas coletadas: ", len(all_data))

klines=all_data


df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df['close'] = pd.to_numeric(df['close'])
df = df[['timestamp', 'close']]



print(df.head())
df_original = df.copy()


# Seleciona apenas as colunas relevantes e converte em um array NumPy
#data = df[['close']].to_numpy()

# Calcular o indicador técnico RSI
rsi_indicator = RSIIndicator(close = df['close'], window = 14)
df['RSI'] = rsi_indicator.rsi()

macd_indicator = ta.trend.MACD(df['close'], window_slow=26, window_fast=12, window_sign=9)
df['MACD'] = macd_indicator.macd()

# Remove os valores NaN do DataFrame
df = df.dropna().reset_index(drop=True)

# Excluir as primeiras linhas que não têm RSI calculadodf = df.dropna().reset_index(drop=True)
print("Número de pontos de dados após remover NaNs: ", len(df))


# Crie um novo scaler para a coluna 'close'
scaler_close = MinMaxScaler()
df[['close']] = scaler_close.fit_transform(df[['close']].values)

# Crie um novo scaler para a coluna 'RSI'
scaler_rsi = MinMaxScaler()
df[['RSI']] = scaler_rsi.fit_transform(df[['RSI']].values)

# Cria um novo scaler para a coluna 'MACD'
scaler_macd = MinMaxScaler()
df[['MACD']] = scaler_macd.fit_transform(df[['MACD']].values)

def create_sequences(data, window):
    xs = []
    ys = []

    for i in range(window, len(data)):
        xs.append(data[i-window:i])
        ys.append(data[i, 0])  # seleciona apenas o preço de fechamento como alvo

    return np.array(xs), np.array(ys)

#data = df[['close', 'RSI']].to_numpy()

data = df[['close', 'RSI', 'MACD']].to_numpy()

# Calcula a quantidade de dias para a previsão
dias_prev = 1


# Calcula o índice onde os dados de treinamento devem terminar e os dados de teste devem começar
train_size = int(len(data) * 0.8)
test_size = len(data) - train_size

# Divide os dados em conjuntos de treinamento e teste
train_data = data[:train_size]
test_data = data[train_size:] # subtraímos LSTM_WINDOW para ter uma sequência completa para o primeiro ponto de teste

# Cria as sequências de treinamento e teste
x_train, y_train = create_sequences(train_data, LSTM_WINDOW)
x_test, y_test = create_sequences(test_data, LSTM_WINDOW)

# Redimensiona os arrays para terem a forma correta para a LSTM
x_train = x_train.reshape((x_train.shape[0], x_train.shape[1], 3))
x_test = x_test.reshape((x_test.shape[0], x_test.shape[1], 3))

# Cria o modelo LSTM bidirecional
model = Sequential()
model.add(SimpleRNN(units=64, return_sequences=True, input_shape=(LSTM_WINDOW, input_dim)))
model.add(Bidirectional(LSTM(units=32, return_sequences=True)))
model.add(BatchNormalization())
model.add(Dropout(0.2))
model.add(Bidirectional(LSTM(units=16)))
#model.add(BatchNormalization())
model.add(Dropout(0.2))
model.add(Dense(1))


model.summary()

print("TREINANDO A REDE NEURAL BI-LSTM...")

# Cria um objeto EarlyStopping
early_stop = EarlyStopping(monitor='val_loss', patience=4)

# Compila e treina o modelo com EarlyStopping
model.compile(optimizer=Adam(learning_rate=0.001), loss='mean_squared_error')
model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=EPOCHS, validation_data=(x_test, y_test), callbacks=[early_stop])

print ("CALCULANDO AS PREVISOES PARA O PROXIMO DIA...")

# Faz a previsão dos valores do par de negociação para os próximos dias_prev dias
# Faz a previsão dos valores do par de negociação para os próximos dias_prev dias
predicted_values = []

# atualiza last_sequence
last_sequence = x_test[-1]

for i in range(dias_prev * 24):  # prevendo os próximos "dias_prev" dias, hora a hora
    predicted_value = model.predict(np.array([last_sequence]))
    predicted_values.append(predicted_value[0][0])
    last_sequence = np.roll(last_sequence, -1, axis=0)
    last_sequence[-1] = predicted_value[0][0]  # usa sempre o último valor previsto

    if i >= len(y_test):
        last_sequence[-1, -1] = predicted_value[0][0] # Usa o último valor previsto para datas futuras
    else:
        last_sequence[-1, -1] = y_test[i] # Insere o valor real no lugar do valor previsto para datas futuras

# Reverte a normalização
predicted_values = np.array(predicted_values).reshape(-1, 1)
predicted_values = scaler_close.inverse_transform(predicted_values)
y_test = y_test.reshape(-1, 1)
y_test = scaler_close.inverse_transform(y_test)

# Cria uma lista com as datas correspondentes à previsão
prev_dates = pd.date_range(start=df_original['timestamp'].iloc[-1] + timedelta(hours=1), periods=dias_prev * 24, freq='H').tolist()

# Cria um DataFrame para exibir os valores previstos e os valores reais dos últimos dias
print(f"Tamanho dos arrays - previsto: {len(predicted_values)} / real: {len(y_test)}")
df_prev = pd.DataFrame({'timestamp': prev_dates, 'Valor Previsto': predicted_values.ravel()})

# Cria o gráfico
fig, ax = plt.subplots(figsize=(12, 8))

# Plot dos valores de 'close' da amostragem
ax.plot(df_original['timestamp'], df_original['close'], color='blue')
ax.plot(df_prev['timestamp'], df_prev['Valor Previsto'], linestyle='--', color='red')

# Configurações do gráfico
ax.set_ylabel('Preço')
ax.set_title('Previsão do preço do par de negociação')

# Define o intervalo do eixo x para mostrar apenas as últimas 24 horas
last_24_hours = pd.date_range(end=df_prev['timestamp'].iloc[-1], periods=24, freq='H')
ax.set_xlim(last_24_hours[0], last_24_hours[-1])

# Mostra o gráfico
plt.show()

# Imprime os valores previstos para as próximas 24 horas
print("Valores previstos para as próximas 24 horas:")
print(df_prev.tail(24).to_string(index=False))
