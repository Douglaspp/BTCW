#import tensorflow as tf
tf.config.run_functions_eagerly(True)
import ccxt
import ta
import pandas as pd
import numpy as np
from binance.client import Client
from binance.enums import *
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional
from datetime import datetime
from tqdm import tqdm
from tensorflow.keras.layers import Flatten
from ta.momentum import RSIIndicator

# Definição dos parâmetros
PAIR = 'BTC/USDT'
PREDICT_DAYS = 10
BATCH_SIZE = 32
EPOCHS = 15
INTERVAL = '1h'  # intervalo de 1 HORA
LSTM_WINDOW = 20 # janela de 60 dias para a LSTM

# Solicitação das datas de início e fim da amostragem
inicio ="01/01/2022" #input('Insira a data de inicio para amostragem (mm/dd/yyyy): ')
fim = "04/30/2023" #input('Insira a data de fim para amostragem (mm/dd/yyyy): ')

# Converte as datas para objeto datetime
inicio_dt = datetime.strptime(inicio, '%m/%d/%Y')
fim_dt = datetime.strptime(fim, '%m/%d/%Y')

# Calcula a quantidade de dias da amostragem
dias_amostra = (fim_dt - inicio_dt).days

# Cria a conexão com a API do Coinbase Pro
exchange = ccxt.coinbasepro()

# Faz a leitura dos dados do par BTCUSDT na Coinbase Pro
print("Carregando dados da API...")
klines = exchange.fetch_ohlcv(PAIR, INTERVAL, since=exchange.parse8601(inicio), limit=dias_amostra*24) # 24 horas por dia

# Cria a barra de progresso
pbar = tqdm(total=len(klines))

df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df['close'] = pd.to_numeric(df['close'])
df = df[['timestamp', 'close']]


# Converte as strings de timestamp para objetos datetime
for kline in klines:
    timestamp = pd.to_datetime(kline[0], unit='ms')
    close = float(kline[4])
    df = df._append({'timestamp': timestamp, 'close': close}, ignore_index=True)
    pbar.update(1)

# Fecha a barra de progresso
pbar.close()

print(df.head())
#df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
#df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
#df['close'] = pd.to_numeric(df['close'])
#df = df[['timestamp', 'close']]
#print(df.head())

# Seleciona apenas as colunas relevantes e converte em um array NumPy
data = df[['close']].to_numpy()

# Calcular o indicador técnico RSI
rsi_indicator = RSIIndicator(close = df['close'], window = 14)
df['RSI'] = rsi_indicator.rsi()

# Excluir as primeiras linhas que não têm RSI calculado
df = df.dropna()

# Crie um novo scaler para a coluna 'close'
scaler_close = MinMaxScaler()
df[['close']] = scaler_close.fit_transform(df[['close']].values)

# Crie um novo scaler para a coluna 'RSI'
scaler_rsi = MinMaxScaler()
df[['RSI']] = scaler_rsi.fit_transform(df[['RSI']].values)

def create_sequences(data, window):
    xs = []
    ys = []

    for i in range(window, len(data)):
        xs.append(data[i-window:i])
        ys.append(data[i, 0])  # seleciona apenas o preço de fechamento como alvo

    return np.array(xs), np.array(ys)

data = df[['close', 'RSI']].to_numpy()

    
# Solicita as datas de início e fim da previsão
inicio_prev ="05/01/2023" #input('Insira a data de inicio para previsao (mm/dd/yyyy): ')
fim_prev = "05/30/2023" #input('Insira a data de fim para previsao (mm/dd/yyyy): ')

# Converte as datas para objetos datetime
df = pd.DataFrame(columns=['timestamp', 'close'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
inicio_prev_dt = datetime.strptime(inicio_prev, '%m/%d/%Y')
fim_prev_dt = datetime.strptime(fim_prev, '%m/%d/%Y') + pd.DateOffset(days=1)

# Calcula a quantidade de dias para a previsão
dias_prev = (fim_prev_dt - inicio_prev_dt).days

# Calcula o índice onde os dados de treinamento devem terminar e os dados de teste devem começar
train_size = int(len(data) * 0.8)

# Divide os dados em conjuntos de treinamento e teste
train_data = data[:train_size]
test_data = data[train_size - LSTM_WINDOW:]  # subtraímos LSTM_WINDOW para ter uma sequência completa para o primeiro ponto de teste

# Cria as sequências de treinamento e teste
x_train, y_train = create_sequences(train_data, LSTM_WINDOW)
x_test, y_test = create_sequences(test_data, LSTM_WINDOW)

# Redimensiona os arrays para terem a forma correta para a LSTM
x_train = x_train.reshape((x_train.shape[0], x_train.shape[1], 2))
x_test = x_test.reshape((x_test.shape[0], x_test.shape[1], 2))

# Cria o modelo LSTM bidirecional
model = Sequential()
model.add(Bidirectional(LSTM(units=64, return_sequences=True), input_shape=(LSTM_WINDOW, 2)))
model.add(Bidirectional(LSTM(units=32)))
model.add(Dense(1))

# Compila e treina o modelo
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=EPOCHS)

# Faz a previsão dos valores do par de negociação para os próximos dias_prev dias
predicted_values = []

# atualiza last_sequence
last_sequence = x_test[-1]

for _ in range(dias_prev):
    predicted_value = model.predict(np.array([last_sequence]))
    predicted_values.append(predicted_value[0][0])
    last_sequence = np.roll(last_sequence, -1, axis=0)
    last_sequence[-1] = np.array([predicted_value[0][0], last_sequence[-1, -1]]) 

     
    if _ >= len(y_test):
        last_sequence[-1, -1] = predicted_value[0][0] # Usa o último valor previsto para datas futuras
    else:
        last_sequence[-1, -1] = y_test[_] # Insere o valor real no lugar do valor previsto para datas futuras


# Reverte a normalização para 'close'
predicted_values = np.array(predicted_values).reshape(-1, 1)
predicted_values = scaler_close.inverse_transform(predicted_values)
y_test = y_test.reshape(-1, 1)
y_test = scaler_close.inverse_transform(y_test)

# Adiciona a coluna 'timestamp' ao DataFrame 'df'
df['timestamp'] = pd.date_range(start=fim_dt + pd.Timedelta(hours=1), periods=len(predicted_values), freq='H')

# Cria um DataFrame para exibir os valores previstos e os valores reais dos últimos dias
print(f"Tamanho dos arrays - previsto: {len(predicted_values)} / real: {len(y_test)}")
df_prev = pd.DataFrame({'timestamp': df['timestamp'], 'Valor Previsto': predicted_values.ravel()})

print(df_prev)
print(df)
