import tensorflow as tf
tf.config.run_functions_eagerly(True)
`tf.data.experimental.enable_debug_mode()
import ccxt
import ta
import time
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from binance.client import Client
from binance.enums import *
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional
from datetime import datetime
from tqdm import tqdm
from tensorflow.keras.layers import Flatten
from ta.momentum import RSIIndicator
from datetime import datetime, timedelta


# Definição dos parâmetros
PAIR = 'BTC/USDT'
PREDICT_DAYS = 10
BATCH_SIZE = 32
EPOCHS = 2
INTERVAL = '1h'  # intervalo de 1 HORA
LSTM_WINDOW = 20 # janela de 60 dias para a LSTM
LIMIT = 1000  # limite de 1000 barras (máximo permitido)

# Configurações
exchange_name = 'coinbasepro'  # Use 'binance', 'kraken', 'coinbasepro', etc.
pair = 'BTC/USDT'  # Par de moedas
interval = '1h'  # Intervalo das velas
inicio = "01/01/2022"
fim = "04/30/2023"

# Criando a conexão com a exchange
exchange = getattr(ccxt, exchange_name)()

# Converte as datas para timestamp em milissegundos
inicio_dt = datetime.strptime(inicio, '%m/%d/%Y')
inicio_ts = int(inicio_dt.timestamp() * 1000)
fim_dt = datetime.strptime(fim, '%m/%d/%Y')
fim_ts = int(fim_dt.timestamp() * 1000)

# Cria uma lista vazia para armazenar todos os dados
all_data = []

# Calcula a diferença em horas
total_hours = int((fim_dt - inicio_dt).total_seconds() / 3600)


print ("BUSCANDO DADOS DA EXCHANGE...")

# Inicializa a barra de progresso
pbar = tqdm(total=total_hours)



while inicio_ts < fim_ts:

    # Busca os dados
    data = exchange.fetch_ohlcv(pair, interval, since=inicio_ts)

    # Se não retornar dados, sai do loop
    if not data:
        break

    # Adiciona os dados à nossa lista
    all_data += data

    # Atualiza o timestamp de início para o timestamp da última vela + intervalo
    inicio_ts = data[-1][0] + 1

    # Atualiza a barra de progresso
    pbar.update(len(data))

    # Pausa para evitar atingir o limite de requisições da API
    time.sleep(exchange.rateLimit / 1000)

pbar.close()

print("Número total de velas coletadas: ", len(all_data))

klines=all_data


df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df['close'] = pd.to_numeric(df['close'])
df = df[['timestamp', 'close']]



print(df.head())


# Seleciona apenas as colunas relevantes e converte em um array NumPy
data = df[['close']].to_numpy()

# Calcular o indicador técnico RSI
rsi_indicator = RSIIndicator(close = df['close'], window = 14)
df['RSI'] = rsi_indicator.rsi()

# Excluir as primeiras linhas que não têm RSI calculado
df = df.dropna()
print("Número de pontos de dados após remover NaNs: ", len(df))


# Crie um novo scaler para a coluna 'close'
scaler_close = MinMaxScaler()
df.loc[:, 'close'] = scaler_close.fit_transform(df[['close']].values)

# Crie um novo scaler para a coluna 'RSI'
scaler_rsi = MinMaxScaler()
df.loc[:, 'RSI'] = scaler_rsi.fit_transform(df[['RSI']].values)


def create_sequences(data, window):
    xs = []
    ys = []

    for i in range(window, len(data)):
        xs.append(data[i-window:i])
        ys.append(data[i, 0])  # seleciona apenas o preço de fechamento como alvo

    return np.array(xs), np.array(ys)

data = df[['close', 'RSI']].to_numpy()

    
# Solicita as datas de início e fim da previsão
inicio_prev ="05/01/2023" #input('Insira a data de inicio para previsao (mm/dd/yyyy): ')
fim_prev = "05/02/2023" #input('Insira a data de fim para previsao (mm/dd/yyyy): ')

# Converte as datas para objetos datetime
df = pd.DataFrame(columns=['timestamp', 'close'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
inicio_prev_dt = datetime.strptime(inicio_prev, '%m/%d/%Y')
fim_prev_dt = datetime.strptime(fim_prev, '%m/%d/%Y') + pd.DateOffset(days=1)

# Calcula a quantidade de dias para a previsão
dias_prev = (fim_prev_dt - inicio_prev_dt).days

# Calcula o índice onde os dados de treinamento devem terminar e os dados de teste devem começar
train_size = int(len(data) * 0.8)
test_size = len(data) - train_size

# Divide os dados em conjuntos de treinamento e teste
train_data = data[:train_size]
test_data = data[train_size:] # subtraímos LSTM_WINDOW para ter uma sequência completa para o primeiro ponto de teste

# Cria as sequências de treinamento e teste
x_train, y_train = create_sequences(train_data, LSTM_WINDOW)
x_test, y_test = create_sequences(test_data, LSTM_WINDOW)

# Redimensiona os arrays para terem a forma correta para a LSTM
x_train = x_train.reshape((x_train.shape[0], x_train.shape[1], 2))
x_test = x_test.reshape((x_test.shape[0], x_test.shape[1], 2))

# Cria o modelo LSTM bidirecional
model = Sequential()
model.add(Bidirectional(LSTM(units=64, return_sequences=True), input_shape=(LSTM_WINDOW, 2)))
model.add(Bidirectional(LSTM(units=32)))
model.add(Dense(1))

model.summary()

# Compila e treina o modelo
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(x_train, y_train, batch_size=BATCH_SIZE, epochs=EPOCHS)

# Faz a previsão dos valores do par de negociação para os próximos dias_prev dias
predicted_values = []

# atualiza last_sequence
last_sequence = x_test[-1]

for i in range(dias_prev * 24):  # prevendo os próximos "dias_prev" dias, hora a hora
    predicted_value = model.predict(np.array([last_sequence]))
    predicted_values.append(predicted_value[0][0])
    last_sequence = np.roll(last_sequence, -1, axis=0)
    last_sequence[-1] = predicted_value[0][0]  # usa sempre o último valor previsto

    if i >= len(y_test):
        last_sequence[-1, -1] = predicted_value[0][0] # Usa o último valor previsto para datas futuras
    else:
        last_sequence[-1, -1] = y_test[i] # Insere o valor real no lugar do valor previsto para datas futuras
# Insere o valor real no lugar do valor previsto para datas futuras


# Reverte a normalização para 'close'
predicted_values = np.array(predicted_values).reshape(-1, 1)
predicted_values = scaler_close.inverse_transform(predicted_values)
y_test = y_test.reshape(-1, 1)
y_test = scaler_close.inverse_transform(y_test)

# Adiciona a coluna 'timestamp' ao DataFrame 'df'
df['timestamp'] = pd.date_range(start=fim_dt + pd.Timedelta(hours=1), periods=len(predicted_values), freq='H')

# Cria um DataFrame para exibir os valores previstos e os valores reais dos últimos dias
print(f"Tamanho dos arrays - previsto: {len(predicted_values)} / real: {len(y_test)}")
df_prev = pd.DataFrame({'timestamp': df['timestamp'], 'Valor Previsto': predicted_values.ravel()})

print(df_prev)
print(df)


# Adiciona os dados de amostragem ao DataFrame de previsão
df_prev = pd.concat([df[['timestamp', 'close']], df_prev], axis=0)


# Plot dos valores de 'close' da amostragem
plt.plot(df['timestamp'], df['close'], color='blue')

# Configurações do gráfico
plt.xlabel('Data')
plt.ylabel('Preço')
plt.title('Preço do par de negociação ao longo do tempo')

# Mostra o gráfico
plt.show()
